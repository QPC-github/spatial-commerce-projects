server {
  listen 80;
  server_name <%= fqdn %>;
  rewrite ^ https://$host$request_uri? permanent;
}

server {
  listen 443 ssl;
  server_name <%= fqdn %>;

  access_log <%= access_log %>;
  error_log <%= error_log %>;

  ssl_certificate <%= ssl_certificate %>;
  ssl_certificate_key <%= ssl_certificate_key %>;

  # require headers for http proxy
  proxy_set_header Client-IP         $remote_addr;
  proxy_set_header X-Real-IP         $remote_addr;
  proxy_set_header X-Forwarded-For   $remote_addr;
  proxy_set_header Host              $http_host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-Port  $server_port;
  proxy_set_header Upgrade           $http_upgrade;
  proxy_set_header Connection        $http_connection;

  proxy_http_version 1.1;
  proxy_redirect off;
  proxy_next_upstream off;
  proxy_read_timeout 30m;

  location /webpack {
    proxy_pass http://127.0.0.1:<%= ENV.fetch("REACT_ASSET_SERVER_PORT", 8080) %>;
  }

  location / {
    # Buffer settings suggested in https://andrewlock.net/fixing-nginx-upstream-sent-too-big-header-error-when-running-an-ingress-controller-in-kubernetes/
    # Without this, very large cookie headers (generated by the auth flow) cause nginx to 502, even when an otherwise valid response is
    # available.
    proxy_buffers         8 16k;
    proxy_buffer_size     16k;
    proxy_pass http://127.0.0.1:<%= ENV.fetch("PORT", 3000) %>;
  }
}
